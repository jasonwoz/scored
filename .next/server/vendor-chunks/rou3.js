"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(rsc)/./node_modules/rou3/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/rou3/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullProtoObj: () => (/* binding */ NullProtoObj),\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute),\n/* harmony export */   routeToRegExp: () => (/* binding */ routeToRegExp)\n/* harmony export */ });\nconst NullProtoObj = /* @__PURE__ */ (() => {\n\tconst e = function() {};\n\treturn e.prototype = Object.create(null), Object.freeze(e.prototype), e;\n})();\n\n/**\n* Create a new router context.\n*/\nfunction createRouter() {\n\treturn {\n\t\troot: { key: \"\" },\n\t\tstatic: new NullProtoObj()\n\t};\n}\n\nfunction splitPath(path) {\n\tconst [_, ...s] = path.split(\"/\");\n\treturn s[s.length - 1] === \"\" ? s.slice(0, -1) : s;\n}\nfunction getMatchParams(segments, paramsMap) {\n\tconst params = new NullProtoObj();\n\tfor (const [index, name] of paramsMap) {\n\t\tconst segment = index < 0 ? segments.slice(-(index + 1)).join(\"/\") : segments[index];\n\t\tif (typeof name === \"string\") params[name] = segment;\n\t\telse {\n\t\t\tconst match = segment.match(name);\n\t\t\tif (match) for (const key in match.groups) params[key] = match.groups[key];\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Add a route to the router context.\n*/\nfunction addRoute(ctx, method = \"\", path, data) {\n\tmethod = method.toUpperCase();\n\tif (path.charCodeAt(0) !== 47) path = `/${path}`;\n\tpath = path.replace(/\\\\:/g, \"%3A\");\n\tconst segments = splitPath(path);\n\tlet node = ctx.root;\n\tlet _unnamedParamIndex = 0;\n\tconst paramsMap = [];\n\tconst paramsRegexp = [];\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tlet segment = segments[i];\n\t\tif (segment.startsWith(\"**\")) {\n\t\t\tif (!node.wildcard) node.wildcard = { key: \"**\" };\n\t\t\tnode = node.wildcard;\n\t\t\tparamsMap.push([\n\t\t\t\t-(i + 1),\n\t\t\t\tsegment.split(\":\")[1] || \"_\",\n\t\t\t\tsegment.length === 2\n\t\t\t]);\n\t\t\tbreak;\n\t\t}\n\t\tif (segment === \"*\" || segment.includes(\":\")) {\n\t\t\tif (!node.param) node.param = { key: \"*\" };\n\t\t\tnode = node.param;\n\t\t\tif (segment === \"*\") paramsMap.push([\n\t\t\t\ti,\n\t\t\t\t`_${_unnamedParamIndex++}`,\n\t\t\t\ttrue\n\t\t\t]);\n\t\t\telse if (segment.includes(\":\", 1)) {\n\t\t\t\tconst regexp = getParamRegexp(segment);\n\t\t\t\tparamsRegexp[i] = regexp;\n\t\t\t\tnode.hasRegexParam = true;\n\t\t\t\tparamsMap.push([\n\t\t\t\t\ti,\n\t\t\t\t\tregexp,\n\t\t\t\t\tfalse\n\t\t\t\t]);\n\t\t\t} else paramsMap.push([\n\t\t\t\ti,\n\t\t\t\tsegment.slice(1),\n\t\t\t\tfalse\n\t\t\t]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (segment === \"\\\\*\") segment = segments[i] = \"*\";\n\t\telse if (segment === \"\\\\*\\\\*\") segment = segments[i] = \"**\";\n\t\tconst child = node.static?.[segment];\n\t\tif (child) node = child;\n\t\telse {\n\t\t\tconst staticNode = { key: segment };\n\t\t\tif (!node.static) node.static = new NullProtoObj();\n\t\t\tnode.static[segment] = staticNode;\n\t\t\tnode = staticNode;\n\t\t}\n\t}\n\tconst hasParams = paramsMap.length > 0;\n\tif (!node.methods) node.methods = new NullProtoObj();\n\tnode.methods[method] ??= [];\n\tnode.methods[method].push({\n\t\tdata: data || null,\n\t\tparamsRegexp,\n\t\tparamsMap: hasParams ? paramsMap : void 0\n\t});\n\tif (!hasParams) ctx.static[\"/\" + segments.join(\"/\")] = node;\n}\nfunction getParamRegexp(segment) {\n\tconst regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\");\n\treturn /* @__PURE__ */ new RegExp(`^${regex}$`);\n}\n\n/**\n* Find a route by path.\n*/\nfunction findRoute(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst staticNode = ctx.static[path];\n\tif (staticNode && staticNode.methods) {\n\t\tconst staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n\t\tif (staticMatch !== void 0) return staticMatch[0];\n\t}\n\tconst segments = splitPath(path);\n\tconst match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n\tif (match === void 0) return;\n\tif (opts?.params === false) return match;\n\treturn {\n\t\tdata: match.data,\n\t\tparams: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n\t};\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods) {\n\t\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\t\tif (match) return match;\n\t\t}\n\t\tif (node.param && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\tif (node.wildcard && node.wildcard.methods) {\n\t\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (node.static) {\n\t\tconst staticChild = node.static[segment];\n\t\tif (staticChild) {\n\t\t\tconst match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n\t\t\tif (match) return match;\n\t\t}\n\t}\n\tif (node.param) {\n\t\tconst match = _lookupTree(ctx, node.param, method, segments, index + 1);\n\t\tif (match) {\n\t\t\tif (node.param.hasRegexParam) {\n\t\t\t\tconst exactMatch = match.find((m) => m.paramsRegexp[index]?.test(segment)) || match.find((m) => !m.paramsRegexp[index]);\n\t\t\t\treturn exactMatch ? [exactMatch] : void 0;\n\t\t\t}\n\t\t\treturn match;\n\t\t}\n\t}\n\tif (node.wildcard && node.wildcard.methods) return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n}\n\n/**\n* Remove a route from the router context.\n*/\nfunction removeRoute(ctx, method, path) {\n\tconst segments = splitPath(path);\n\treturn _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods && method in node.methods) {\n\t\t\tdelete node.methods[method];\n\t\t\tif (Object.keys(node.methods).length === 0) node.methods = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (segment === \"*\") {\n\t\tif (node.param) {\n\t\t\t_remove(node.param, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.param)) node.param = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (segment.startsWith(\"**\")) {\n\t\tif (node.wildcard) {\n\t\t\t_remove(node.wildcard, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.wildcard)) node.wildcard = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst childNode = node.static?.[segment];\n\tif (childNode) {\n\t\t_remove(childNode, method, segments, index + 1);\n\t\tif (_isEmptyNode(childNode)) {\n\t\t\tdelete node.static[segment];\n\t\t\tif (Object.keys(node.static).length === 0) node.static = void 0;\n\t\t}\n\t}\n}\nfunction _isEmptyNode(node) {\n\treturn node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\n/**\n* Find all route patterns that match the given path.\n*/\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst segments = splitPath(path);\n\tconst matches = _findAll(ctx, ctx.root, method, segments, 0);\n\tif (opts?.params === false) return matches;\n\treturn matches.map((m) => {\n\t\treturn {\n\t\t\tdata: m.data,\n\t\t\tparams: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n\t\t};\n\t});\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n\tconst segment = segments[index];\n\tif (node.wildcard && node.wildcard.methods) {\n\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\tif (node.param) {\n\t\t_findAll(ctx, node.param, method, segments, index + 1, matches);\n\t\tif (index === segments.length && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) matches.push(...match);\n\t\t\t}\n\t\t}\n\t}\n\tconst staticChild = node.static?.[segment];\n\tif (staticChild) _findAll(ctx, staticChild, method, segments, index + 1, matches);\n\tif (index === segments.length && node.methods) {\n\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\treturn matches;\n}\n\nfunction routeToRegExp(route = \"/\") {\n\tconst reSegments = [];\n\tlet idCtr = 0;\n\tfor (const segment of route.split(\"/\")) {\n\t\tif (!segment) continue;\n\t\tif (segment === \"*\") reSegments.push(`(?<_${idCtr++}>[^/]*)`);\n\t\telse if (segment.startsWith(\"**\")) reSegments.push(segment === \"**\" ? \"?(?<_>.*)\" : `?(?<${segment.slice(3)}>.+)`);\n\t\telse if (segment.includes(\":\")) reSegments.push(segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\"));\n\t\telse reSegments.push(segment);\n\t}\n\treturn /* @__PURE__ */ new RegExp(`^/${reSegments.join(\"/\")}/?$`);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlELHVDQUF1QyxNQUFNO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQsNkZBQTZGLGlCQUFpQjtBQUM5Ryw4RkFBOEYsR0FBRztBQUNqRztBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL3dvei93b3Jrc3BhY2Uvc2NvcmVkL3Njb3JlZC9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBOdWxsUHJvdG9PYmogPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcblx0Y29uc3QgZSA9IGZ1bmN0aW9uKCkge307XG5cdHJldHVybiBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCksIE9iamVjdC5mcmVlemUoZS5wcm90b3R5cGUpLCBlO1xufSkoKTtcblxuLyoqXG4qIENyZWF0ZSBhIG5ldyByb3V0ZXIgY29udGV4dC5cbiovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoKSB7XG5cdHJldHVybiB7XG5cdFx0cm9vdDogeyBrZXk6IFwiXCIgfSxcblx0XHRzdGF0aWM6IG5ldyBOdWxsUHJvdG9PYmooKVxuXHR9O1xufVxuXG5mdW5jdGlvbiBzcGxpdFBhdGgocGF0aCkge1xuXHRjb25zdCBbXywgLi4uc10gPSBwYXRoLnNwbGl0KFwiL1wiKTtcblx0cmV0dXJuIHNbcy5sZW5ndGggLSAxXSA9PT0gXCJcIiA/IHMuc2xpY2UoMCwgLTEpIDogcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBwYXJhbXNNYXApIHtcblx0Y29uc3QgcGFyYW1zID0gbmV3IE51bGxQcm90b09iaigpO1xuXHRmb3IgKGNvbnN0IFtpbmRleCwgbmFtZV0gb2YgcGFyYW1zTWFwKSB7XG5cdFx0Y29uc3Qgc2VnbWVudCA9IGluZGV4IDwgMCA/IHNlZ21lbnRzLnNsaWNlKC0oaW5kZXggKyAxKSkuam9pbihcIi9cIikgOiBzZWdtZW50c1tpbmRleF07XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSBwYXJhbXNbbmFtZV0gPSBzZWdtZW50O1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKG5hbWUpO1xuXHRcdFx0aWYgKG1hdGNoKSBmb3IgKGNvbnN0IGtleSBpbiBtYXRjaC5ncm91cHMpIHBhcmFtc1trZXldID0gbWF0Y2guZ3JvdXBzW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBwYXJhbXM7XG59XG5cbi8qKlxuKiBBZGQgYSByb3V0ZSB0byB0aGUgcm91dGVyIGNvbnRleHQuXG4qL1xuZnVuY3Rpb24gYWRkUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBkYXRhKSB7XG5cdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXHRpZiAocGF0aC5jaGFyQ29kZUF0KDApICE9PSA0NykgcGF0aCA9IGAvJHtwYXRofWA7XG5cdHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFw6L2csIFwiJTNBXCIpO1xuXHRjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcblx0bGV0IG5vZGUgPSBjdHgucm9vdDtcblx0bGV0IF91bm5hbWVkUGFyYW1JbmRleCA9IDA7XG5cdGNvbnN0IHBhcmFtc01hcCA9IFtdO1xuXHRjb25zdCBwYXJhbXNSZWdleHAgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0aWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSB7XG5cdFx0XHRpZiAoIW5vZGUud2lsZGNhcmQpIG5vZGUud2lsZGNhcmQgPSB7IGtleTogXCIqKlwiIH07XG5cdFx0XHRub2RlID0gbm9kZS53aWxkY2FyZDtcblx0XHRcdHBhcmFtc01hcC5wdXNoKFtcblx0XHRcdFx0LShpICsgMSksXG5cdFx0XHRcdHNlZ21lbnQuc3BsaXQoXCI6XCIpWzFdIHx8IFwiX1wiLFxuXHRcdFx0XHRzZWdtZW50Lmxlbmd0aCA9PT0gMlxuXHRcdFx0XSk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHNlZ21lbnQgPT09IFwiKlwiIHx8IHNlZ21lbnQuaW5jbHVkZXMoXCI6XCIpKSB7XG5cdFx0XHRpZiAoIW5vZGUucGFyYW0pIG5vZGUucGFyYW0gPSB7IGtleTogXCIqXCIgfTtcblx0XHRcdG5vZGUgPSBub2RlLnBhcmFtO1xuXHRcdFx0aWYgKHNlZ21lbnQgPT09IFwiKlwiKSBwYXJhbXNNYXAucHVzaChbXG5cdFx0XHRcdGksXG5cdFx0XHRcdGBfJHtfdW5uYW1lZFBhcmFtSW5kZXgrK31gLFxuXHRcdFx0XHR0cnVlXG5cdFx0XHRdKTtcblx0XHRcdGVsc2UgaWYgKHNlZ21lbnQuaW5jbHVkZXMoXCI6XCIsIDEpKSB7XG5cdFx0XHRcdGNvbnN0IHJlZ2V4cCA9IGdldFBhcmFtUmVnZXhwKHNlZ21lbnQpO1xuXHRcdFx0XHRwYXJhbXNSZWdleHBbaV0gPSByZWdleHA7XG5cdFx0XHRcdG5vZGUuaGFzUmVnZXhQYXJhbSA9IHRydWU7XG5cdFx0XHRcdHBhcmFtc01hcC5wdXNoKFtcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHJlZ2V4cCxcblx0XHRcdFx0XHRmYWxzZVxuXHRcdFx0XHRdKTtcblx0XHRcdH0gZWxzZSBwYXJhbXNNYXAucHVzaChbXG5cdFx0XHRcdGksXG5cdFx0XHRcdHNlZ21lbnQuc2xpY2UoMSksXG5cdFx0XHRcdGZhbHNlXG5cdFx0XHRdKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoc2VnbWVudCA9PT0gXCJcXFxcKlwiKSBzZWdtZW50ID0gc2VnbWVudHNbaV0gPSBcIipcIjtcblx0XHRlbHNlIGlmIChzZWdtZW50ID09PSBcIlxcXFwqXFxcXCpcIikgc2VnbWVudCA9IHNlZ21lbnRzW2ldID0gXCIqKlwiO1xuXHRcdGNvbnN0IGNoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcblx0XHRpZiAoY2hpbGQpIG5vZGUgPSBjaGlsZDtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IHN0YXRpY05vZGUgPSB7IGtleTogc2VnbWVudCB9O1xuXHRcdFx0aWYgKCFub2RlLnN0YXRpYykgbm9kZS5zdGF0aWMgPSBuZXcgTnVsbFByb3RvT2JqKCk7XG5cdFx0XHRub2RlLnN0YXRpY1tzZWdtZW50XSA9IHN0YXRpY05vZGU7XG5cdFx0XHRub2RlID0gc3RhdGljTm9kZTtcblx0XHR9XG5cdH1cblx0Y29uc3QgaGFzUGFyYW1zID0gcGFyYW1zTWFwLmxlbmd0aCA+IDA7XG5cdGlmICghbm9kZS5tZXRob2RzKSBub2RlLm1ldGhvZHMgPSBuZXcgTnVsbFByb3RvT2JqKCk7XG5cdG5vZGUubWV0aG9kc1ttZXRob2RdID8/PSBbXTtcblx0bm9kZS5tZXRob2RzW21ldGhvZF0ucHVzaCh7XG5cdFx0ZGF0YTogZGF0YSB8fCBudWxsLFxuXHRcdHBhcmFtc1JlZ2V4cCxcblx0XHRwYXJhbXNNYXA6IGhhc1BhcmFtcyA/IHBhcmFtc01hcCA6IHZvaWQgMFxuXHR9KTtcblx0aWYgKCFoYXNQYXJhbXMpIGN0eC5zdGF0aWNbXCIvXCIgKyBzZWdtZW50cy5qb2luKFwiL1wiKV0gPSBub2RlO1xufVxuZnVuY3Rpb24gZ2V0UGFyYW1SZWdleHAoc2VnbWVudCkge1xuXHRjb25zdCByZWdleCA9IHNlZ21lbnQucmVwbGFjZSgvOihcXHcrKS9nLCAoXywgaWQpID0+IGAoPzwke2lkfT5bXi9dKylgKS5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKTtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5cbi8qKlxuKiBGaW5kIGEgcm91dGUgYnkgcGF0aC5cbiovXG5mdW5jdGlvbiBmaW5kUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG5cdGlmIChwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcpIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcblx0Y29uc3Qgc3RhdGljTm9kZSA9IGN0eC5zdGF0aWNbcGF0aF07XG5cdGlmIChzdGF0aWNOb2RlICYmIHN0YXRpY05vZGUubWV0aG9kcykge1xuXHRcdGNvbnN0IHN0YXRpY01hdGNoID0gc3RhdGljTm9kZS5tZXRob2RzW21ldGhvZF0gfHwgc3RhdGljTm9kZS5tZXRob2RzW1wiXCJdO1xuXHRcdGlmIChzdGF0aWNNYXRjaCAhPT0gdm9pZCAwKSByZXR1cm4gc3RhdGljTWF0Y2hbMF07XG5cdH1cblx0Y29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG5cdGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk/LlswXTtcblx0aWYgKG1hdGNoID09PSB2b2lkIDApIHJldHVybjtcblx0aWYgKG9wdHM/LnBhcmFtcyA9PT0gZmFsc2UpIHJldHVybiBtYXRjaDtcblx0cmV0dXJuIHtcblx0XHRkYXRhOiBtYXRjaC5kYXRhLFxuXHRcdHBhcmFtczogbWF0Y2gucGFyYW1zTWFwID8gZ2V0TWF0Y2hQYXJhbXMoc2VnbWVudHMsIG1hdGNoLnBhcmFtc01hcCkgOiB2b2lkIDBcblx0fTtcbn1cbmZ1bmN0aW9uIF9sb29rdXBUcmVlKGN0eCwgbm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcblx0aWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAobm9kZS5tZXRob2RzKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcblx0XHRcdGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoO1xuXHRcdH1cblx0XHRpZiAobm9kZS5wYXJhbSAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdGNvbnN0IHBNYXAgPSBtYXRjaFswXS5wYXJhbXNNYXA7XG5cdFx0XHRcdGlmIChwTWFwPy5bcE1hcD8ubGVuZ3RoIC0gMV0/LlsyXSkgcmV0dXJuIG1hdGNoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdGNvbnN0IHBNYXAgPSBtYXRjaFswXS5wYXJhbXNNYXA7XG5cdFx0XHRcdGlmIChwTWFwPy5bcE1hcD8ubGVuZ3RoIC0gMV0/LlsyXSkgcmV0dXJuIG1hdGNoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcblx0aWYgKG5vZGUuc3RhdGljKSB7XG5cdFx0Y29uc3Qgc3RhdGljQ2hpbGQgPSBub2RlLnN0YXRpY1tzZWdtZW50XTtcblx0XHRpZiAoc3RhdGljQ2hpbGQpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcblx0XHRcdGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoO1xuXHRcdH1cblx0fVxuXHRpZiAobm9kZS5wYXJhbSkge1xuXHRcdGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0aWYgKG5vZGUucGFyYW0uaGFzUmVnZXhQYXJhbSkge1xuXHRcdFx0XHRjb25zdCBleGFjdE1hdGNoID0gbWF0Y2guZmluZCgobSkgPT4gbS5wYXJhbXNSZWdleHBbaW5kZXhdPy50ZXN0KHNlZ21lbnQpKSB8fCBtYXRjaC5maW5kKChtKSA9PiAhbS5wYXJhbXNSZWdleHBbaW5kZXhdKTtcblx0XHRcdFx0cmV0dXJuIGV4YWN0TWF0Y2ggPyBbZXhhY3RNYXRjaF0gOiB2b2lkIDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXHR9XG5cdGlmIChub2RlLndpbGRjYXJkICYmIG5vZGUud2lsZGNhcmQubWV0aG9kcykgcmV0dXJuIG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbn1cblxuLyoqXG4qIFJlbW92ZSBhIHJvdXRlIGZyb20gdGhlIHJvdXRlciBjb250ZXh0LlxuKi9cbmZ1bmN0aW9uIHJlbW92ZVJvdXRlKGN0eCwgbWV0aG9kLCBwYXRoKSB7XG5cdGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuXHRyZXR1cm4gX3JlbW92ZShjdHgucm9vdCwgbWV0aG9kIHx8IFwiXCIsIHNlZ21lbnRzLCAwKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcblx0aWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAobm9kZS5tZXRob2RzICYmIG1ldGhvZCBpbiBub2RlLm1ldGhvZHMpIHtcblx0XHRcdGRlbGV0ZSBub2RlLm1ldGhvZHNbbWV0aG9kXTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGhvZHMpLmxlbmd0aCA9PT0gMCkgbm9kZS5tZXRob2RzID0gdm9pZCAwO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcblx0aWYgKHNlZ21lbnQgPT09IFwiKlwiKSB7XG5cdFx0aWYgKG5vZGUucGFyYW0pIHtcblx0XHRcdF9yZW1vdmUobm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcblx0XHRcdGlmIChfaXNFbXB0eU5vZGUobm9kZS5wYXJhbSkpIG5vZGUucGFyYW0gPSB2b2lkIDA7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc2VnbWVudC5zdGFydHNXaXRoKFwiKipcIikpIHtcblx0XHRpZiAobm9kZS53aWxkY2FyZCkge1xuXHRcdFx0X3JlbW92ZShub2RlLndpbGRjYXJkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuXHRcdFx0aWYgKF9pc0VtcHR5Tm9kZShub2RlLndpbGRjYXJkKSkgbm9kZS53aWxkY2FyZCA9IHZvaWQgMDtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IGNoaWxkTm9kZSA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG5cdGlmIChjaGlsZE5vZGUpIHtcblx0XHRfcmVtb3ZlKGNoaWxkTm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcblx0XHRpZiAoX2lzRW1wdHlOb2RlKGNoaWxkTm9kZSkpIHtcblx0XHRcdGRlbGV0ZSBub2RlLnN0YXRpY1tzZWdtZW50XTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhub2RlLnN0YXRpYykubGVuZ3RoID09PSAwKSBub2RlLnN0YXRpYyA9IHZvaWQgMDtcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIF9pc0VtcHR5Tm9kZShub2RlKSB7XG5cdHJldHVybiBub2RlLm1ldGhvZHMgPT09IHZvaWQgMCAmJiBub2RlLnN0YXRpYyA9PT0gdm9pZCAwICYmIG5vZGUucGFyYW0gPT09IHZvaWQgMCAmJiBub2RlLndpbGRjYXJkID09PSB2b2lkIDA7XG59XG5cbi8qKlxuKiBGaW5kIGFsbCByb3V0ZSBwYXR0ZXJucyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXRoLlxuKi9cbmZ1bmN0aW9uIGZpbmRBbGxSb3V0ZXMoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG5cdGlmIChwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcpIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcblx0Y29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG5cdGNvbnN0IG1hdGNoZXMgPSBfZmluZEFsbChjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKTtcblx0aWYgKG9wdHM/LnBhcmFtcyA9PT0gZmFsc2UpIHJldHVybiBtYXRjaGVzO1xuXHRyZXR1cm4gbWF0Y2hlcy5tYXAoKG0pID0+IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YTogbS5kYXRhLFxuXHRcdFx0cGFyYW1zOiBtLnBhcmFtc01hcCA/IGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBtLnBhcmFtc01hcCkgOiB2b2lkIDBcblx0XHR9O1xuXHR9KTtcbn1cbmZ1bmN0aW9uIF9maW5kQWxsKGN0eCwgbm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgsIG1hdGNoZXMgPSBbXSkge1xuXHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuXHRpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHtcblx0XHRjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcblx0XHRpZiAobWF0Y2gpIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG5cdH1cblx0aWYgKG5vZGUucGFyYW0pIHtcblx0XHRfZmluZEFsbChjdHgsIG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSwgbWF0Y2hlcyk7XG5cdFx0aWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcblx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuXHRcdFx0XHRpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcblx0aWYgKHN0YXRpY0NoaWxkKSBfZmluZEFsbChjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEsIG1hdGNoZXMpO1xuXHRpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLm1ldGhvZHMpIHtcblx0XHRjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcblx0XHRpZiAobWF0Y2gpIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG5cdH1cblx0cmV0dXJuIG1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIHJvdXRlVG9SZWdFeHAocm91dGUgPSBcIi9cIikge1xuXHRjb25zdCByZVNlZ21lbnRzID0gW107XG5cdGxldCBpZEN0ciA9IDA7XG5cdGZvciAoY29uc3Qgc2VnbWVudCBvZiByb3V0ZS5zcGxpdChcIi9cIikpIHtcblx0XHRpZiAoIXNlZ21lbnQpIGNvbnRpbnVlO1xuXHRcdGlmIChzZWdtZW50ID09PSBcIipcIikgcmVTZWdtZW50cy5wdXNoKGAoPzxfJHtpZEN0cisrfT5bXi9dKilgKTtcblx0XHRlbHNlIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoXCIqKlwiKSkgcmVTZWdtZW50cy5wdXNoKHNlZ21lbnQgPT09IFwiKipcIiA/IFwiPyg/PF8+LiopXCIgOiBgPyg/PCR7c2VnbWVudC5zbGljZSgzKX0+LispYCk7XG5cdFx0ZWxzZSBpZiAoc2VnbWVudC5pbmNsdWRlcyhcIjpcIikpIHJlU2VnbWVudHMucHVzaChzZWdtZW50LnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGlkKSA9PiBgKD88JHtpZH0+W14vXSspYCkucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIikpO1xuXHRcdGVsc2UgcmVTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHR9XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgXi8ke3JlU2VnbWVudHMuam9pbihcIi9cIil9Lz8kYCk7XG59XG5cbmV4cG9ydCB7IE51bGxQcm90b09iaiwgYWRkUm91dGUsIGNyZWF0ZVJvdXRlciwgZmluZEFsbFJvdXRlcywgZmluZFJvdXRlLCByZW1vdmVSb3V0ZSwgcm91dGVUb1JlZ0V4cCB9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;